#include <iostream>   // Нужен, чтобы мы могли писать в консоль (cout) и читать из неё (cin)
#include <random>     // Нужен для генерации случайных чисел
#include <omp.h>      // Подключаем OpenMP для параллельных вычислений

// g++ -O2 -fopenmp main.cpp -o main

// ---------------------------------------------------------
// Функция заполняет массив случайными числами
// arr - это указатель на начало массива (адрес первого элемента)
// n - сколько элементов в массиве
// ---------------------------------------------------------
void fillRandom(int* arr, int n, int minVal, int maxVal) {

    // Получаем "случайное зерно" от операционной системы
    // Нужно, чтобы каждый запуск программы давал разные числа
    std::random_device rd;

    // Создаём генератор случайных чисел
    std::mt19937 gen(rd());

    // Говорим генератору: «давай целые числа от minVal до maxVal»
    std::uniform_int_distribution<int> dist(minVal, maxVal);

    // Проходим по каждому элементу массива
    for (int i = 0; i < n; i++) {

        // arr[i] — это i-й элемент массива
        // На самом деле это сокращение от *(arr + i)
        // То есть: взять адрес arr, сместиться на i элементов и записать туда число
        arr[i] = dist(gen);
    }
}

// ---------------------------------------------------------
// Обычный (НЕ параллельный) подсчёт среднего значения
// ---------------------------------------------------------
double averageSequential(const int* arr, int n) {

    // Здесь будем хранить сумму всех элементов
    // long long — чтобы сумма не "переполнилась"
    long long sum = 0;

    // Просто идём по массиву и складываем элементы
    for (int i = 0; i < n; i++) {
        sum += arr[i];
    }

    // Делим сумму на количество элементов
    // Приводим к double, чтобы не было целочисленного деления
    return (double)sum / n;
}

// ---------------------------------------------------------
// Параллельный подсчёт среднего значения с OpenMP
// ---------------------------------------------------------
double averageParallel(const int* arr, int n) {

    // Это общая сумма
    long long sum = 0;

    // parallel for      -> цикл выполняется сразу в нескольких потоках
    // reduction(+:sum)  -> каждый поток считает СВОЮ сумму,
    //                      а потом OpenMP аккуратно складывает их вместе
    //
    // Без reduction здесь был бы хаос и неправильные результаты
    #pragma omp parallel for reduction(+:sum)
    for (int i = 0; i < n; i++) {

        // Каждый поток добавляет свои элементы
        sum += arr[i];
    }

    // Возвращаем среднее значение
    return (double)sum / n;
}

int main() {

    // Размер массива
    int n;

    // Просим пользователя ввести размер массива
    std::cout << "Enter array size: ";
    std::cin >> n;

    // Проверяем, что размер нормальный
    if (n <= 0) {
        std::cout << "Array size must be positive\n";
        return 1;
    }

    // -------------------------------------------------
    // ВЫДЕЛЕНИЕ ПАМЯТИ
    // -------------------------------------------------
    // new int[n] — компьютер выделяет место в памяти
    // под n целых чисел и возвращает адрес первого
    int* arr = new int[n];

    // -------------------------------------------------
    // ЗАПОЛНЕНИЕ МАССИВА
    // -------------------------------------------------
    fillRandom(arr, n, 0, 100);

    // Покажем первые элементы, чтобы убедиться, что всё работает
    int show = (n < 10) ? n : 10;

    std::cout << "First elements: ";
    for (int i = 0; i < show; i++) {
        std::cout << arr[i] << " ";
    }
    std::cout << "\n";


    // --------- SEQ TIME ----------
    double t1 = omp_get_wtime();
    double avgSeq = averageSequential(arr, n);
    double t2 = omp_get_wtime();

    // --------- PAR TIME ----------
    double t3 = omp_get_wtime();
    double avgPar = averageParallel(arr, n);
    double t4 = omp_get_wtime();

    std::cout << "Average (sequential): " << avgSeq << "\n";
    std::cout << "Average (parallel)  : " << avgPar << "\n";
    std::cout << "Time seq: " << (t2 - t1) << " sec\n";
    std::cout << "Time par: " << (t4 - t3) << " sec\n";

    // Показываем, сколько потоков OpenMP может использовать
    std::cout << "OpenMP threads available: "
              << omp_get_max_threads() << "\n";

    #pragma omp parallel
    {
        #pragma omp single
        std::cout << "OpenMP actually using threads: " << omp_get_num_threads() << "\n";
    }

    
    // -------------------------------------------------
    // ОСВОБОЖДЕНИЕ ПАМЯТИ
    // -------------------------------------------------
    // Мы сами выделили память — мы обязаны её вернуть
    delete[] arr;

    // После освобождения делаем указатель пустым,
    // чтобы случайно не использовать мусор
    arr = nullptr;

    // Всё прошло успешно
    return 0;
}


